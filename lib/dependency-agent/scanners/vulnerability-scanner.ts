/**
 * Vulnerability Scanner
 *
 * Runs `npm audit --json` and parses results into DependencyFindings.
 * Maps npm severity levels to DependencySeverity.
 */

import { execSync } from 'child_process';
import { DependencyFinding, ScannerResult, DependencySeverity } from '../types';

// Map npm audit severity to our severity levels
const SEVERITY_MAP: Record<string, DependencySeverity> = {
  critical: 'critical',
  high: 'high',
  moderate: 'medium',
  low: 'low',
  info: 'info',
};

interface NpmAuditAdvisory {
  name: string;
  severity: string;
  title: string;
  url: string;
  cves?: string[];
  range: string;
  fixAvailable?: boolean | { name: string; version: string };
}

interface NpmAuditOutput {
  vulnerabilities?: Record<string, NpmAuditAdvisory>;
  metadata?: {
    vulnerabilities: Record<string, number>;
    dependencies: { total: number };
  };
}

/**
 * Parse npm audit JSON output into findings.
 */
export function parseNpmAuditOutput(jsonStr: string): DependencyFinding[] {
  const findings: DependencyFinding[] = [];

  try {
    const audit: NpmAuditOutput = JSON.parse(jsonStr);
    const vulns = audit.vulnerabilities || {};

    for (const [pkgName, advisory] of Object.entries(vulns)) {
      const severity = SEVERITY_MAP[advisory.severity] || 'medium';
      const cveId = advisory.cves?.[0];

      let suggestion: string | undefined;
      if (advisory.fixAvailable) {
        if (typeof advisory.fixAvailable === 'object') {
          suggestion = `Update ${advisory.fixAvailable.name} to ${advisory.fixAvailable.version}`;
        } else {
          suggestion = 'Run npm audit fix';
        }
      }

      findings.push({
        category: 'vulnerability',
        severity,
        package: pkgName,
        message: advisory.title || `Vulnerability in ${pkgName}`,
        cveId,
        suggestion,
      });
    }
  } catch {
    // JSON parse error — return empty
  }

  return findings;
}

/**
 * Run the vulnerability scanner.
 */
export async function runVulnerabilityScanner(projectRoot: string): Promise<ScannerResult> {
  const start = Date.now();
  const findings: DependencyFinding[] = [];

  try {
    let auditOutput: string;
    try {
      // npm audit returns non-zero exit code when vulnerabilities are found
      auditOutput = execSync('npm audit --json 2>/dev/null', {
        cwd: projectRoot,
        encoding: 'utf-8',
        maxBuffer: 10 * 1024 * 1024,
        timeout: 30000,
      });
    } catch (error: any) {
      // npm audit exits with non-zero when vulns found — still has JSON output
      auditOutput = error.stdout || '{}';
    }

    findings.push(...parseNpmAuditOutput(auditOutput));

    return {
      scanner: 'vulnerability-scanner',
      findings,
      durationMs: Date.now() - start,
    };
  } catch (error: any) {
    return {
      scanner: 'vulnerability-scanner',
      findings,
      durationMs: Date.now() - start,
      error: error.message,
    };
  }
}
